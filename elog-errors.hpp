// This file was autogenerated.  Do not edit!
// See elog-gen.py for more details
#pragma once

#include <string>
#include <tuple>
#include <type_traits>
#include <sdbusplus/exception.hpp>
#include <phosphor-logging/log.hpp>
#include <phosphor-logging/elog.hpp>

namespace sdbusplus
{
namespace xyz
{
namespace openbmc_project
{
namespace Power
{
namespace Fault
{
namespace Error
{
    struct PowerOnFailure;
} // namespace Error
} // namespace Fault
} // namespace Power
} // namespace openbmc_project
} // namespace xyz
} // namespace sdbusplus

namespace sdbusplus
{
namespace xyz
{
namespace openbmc_project
{
namespace Power
{
namespace Fault
{
namespace Error
{
    struct PowerSequencerPGOODFault;
} // namespace Error
} // namespace Fault
} // namespace Power
} // namespace openbmc_project
} // namespace xyz
} // namespace sdbusplus

namespace sdbusplus
{
namespace xyz
{
namespace openbmc_project
{
namespace Power
{
namespace Fault
{
namespace Error
{
    struct PowerSequencerVoltageFault;
} // namespace Error
} // namespace Fault
} // namespace Power
} // namespace openbmc_project
} // namespace xyz
} // namespace sdbusplus

namespace sdbusplus
{
namespace xyz
{
namespace openbmc_project
{
namespace Power
{
namespace Fault
{
namespace Error
{
    struct PowerSequencerFault;
} // namespace Error
} // namespace Fault
} // namespace Power
} // namespace openbmc_project
} // namespace xyz
} // namespace sdbusplus

namespace sdbusplus
{
namespace xyz
{
namespace openbmc_project
{
namespace Power
{
namespace Fault
{
namespace Error
{
    struct Shutdown;
} // namespace Error
} // namespace Fault
} // namespace Power
} // namespace openbmc_project
} // namespace xyz
} // namespace sdbusplus


namespace phosphor
{

namespace logging
{

namespace xyz
{
namespace openbmc_project
{
namespace Power
{
namespace Fault
{
namespace _Shutdown
{


}  // namespace _Shutdown

struct Shutdown
{
    static constexpr auto L = level::ERR;
    using metadata_types = std::tuple<>;

};

} // namespace Fault
} // namespace Power
} // namespace openbmc_project
} // namespace xyz


namespace details
{

template <>
struct map_exception_type<sdbusplus::xyz::openbmc_project::Power::Fault::Error::Shutdown>
{
    using type = xyz::openbmc_project::Power::Fault::Shutdown;
};

}

namespace xyz
{
namespace openbmc_project
{
namespace Power
{
namespace Fault
{
namespace _PowerOnFailure
{


}  // namespace _PowerOnFailure

struct PowerOnFailure
{
    static constexpr auto L = level::ERR;
    using metadata_types = std::tuple<>;

};

} // namespace Fault
} // namespace Power
} // namespace openbmc_project
} // namespace xyz


namespace details
{

template <>
struct map_exception_type<sdbusplus::xyz::openbmc_project::Power::Fault::Error::PowerOnFailure>
{
    using type = xyz::openbmc_project::Power::Fault::PowerOnFailure;
};

}

namespace xyz
{
namespace openbmc_project
{
namespace Power
{
namespace Fault
{
namespace _PowerSequencerVoltageFault
{

struct RAIL
{
    static constexpr auto str = "RAIL=%d";
    static constexpr auto str_short = "RAIL";
    using type = std::tuple<std::decay_t<decltype(str)>,uint16_t>;
    explicit constexpr RAIL(uint16_t a) : _entry(entry(str, a)) {};
    type _entry;
};
struct RAIL_NAME
{
    static constexpr auto str = "RAIL_NAME=%s";
    static constexpr auto str_short = "RAIL_NAME";
    using type = std::tuple<std::decay_t<decltype(str)>,const char*>;
    explicit constexpr RAIL_NAME(const char* a) : _entry(entry(str, a)) {};
    type _entry;
};
struct STATUS_WORD
{
    static constexpr auto str = "STATUS_WORD=0x%04X";
    static constexpr auto str_short = "STATUS_WORD";
    using type = std::tuple<std::decay_t<decltype(str)>,uint16_t>;
    explicit constexpr STATUS_WORD(uint16_t a) : _entry(entry(str, a)) {};
    type _entry;
};
struct STATUS_VOUT
{
    static constexpr auto str = "STATUS_VOUT=0x%02X";
    static constexpr auto str_short = "STATUS_VOUT";
    using type = std::tuple<std::decay_t<decltype(str)>,uint16_t>;
    explicit constexpr STATUS_VOUT(uint16_t a) : _entry(entry(str, a)) {};
    type _entry;
};
struct MFR_STATUS
{
    static constexpr auto str = "MFR_STATUS=0x%08X";
    static constexpr auto str_short = "MFR_STATUS";
    using type = std::tuple<std::decay_t<decltype(str)>,uint32_t>;
    explicit constexpr MFR_STATUS(uint32_t a) : _entry(entry(str, a)) {};
    type _entry;
};

}  // namespace _PowerSequencerVoltageFault

struct PowerSequencerVoltageFault
{
    static constexpr auto L = level::ERR;
    using RAIL = _PowerSequencerVoltageFault::RAIL;
    using RAIL_NAME = _PowerSequencerVoltageFault::RAIL_NAME;
    using STATUS_WORD = _PowerSequencerVoltageFault::STATUS_WORD;
    using STATUS_VOUT = _PowerSequencerVoltageFault::STATUS_VOUT;
    using MFR_STATUS = _PowerSequencerVoltageFault::MFR_STATUS;
    using metadata_types = std::tuple<RAIL, RAIL_NAME, STATUS_WORD, STATUS_VOUT, MFR_STATUS>;

};

} // namespace Fault
} // namespace Power
} // namespace openbmc_project
} // namespace xyz


namespace details
{

template <>
struct map_exception_type<sdbusplus::xyz::openbmc_project::Power::Fault::Error::PowerSequencerVoltageFault>
{
    using type = xyz::openbmc_project::Power::Fault::PowerSequencerVoltageFault;
};

}

namespace xyz
{
namespace openbmc_project
{
namespace Power
{
namespace Fault
{
namespace _PowerSequencerPGOODFault
{

struct INPUT_NUM
{
    static constexpr auto str = "INPUT_NUM=%d";
    static constexpr auto str_short = "INPUT_NUM";
    using type = std::tuple<std::decay_t<decltype(str)>,uint16_t>;
    explicit constexpr INPUT_NUM(uint16_t a) : _entry(entry(str, a)) {};
    type _entry;
};
struct INPUT_NAME
{
    static constexpr auto str = "INPUT_NAME=%s";
    static constexpr auto str_short = "INPUT_NAME";
    using type = std::tuple<std::decay_t<decltype(str)>,const char*>;
    explicit constexpr INPUT_NAME(const char* a) : _entry(entry(str, a)) {};
    type _entry;
};
struct INPUT_STATUS
{
    static constexpr auto str = "INPUT_STATUS=%d";
    static constexpr auto str_short = "INPUT_STATUS";
    using type = std::tuple<std::decay_t<decltype(str)>,uint16_t>;
    explicit constexpr INPUT_STATUS(uint16_t a) : _entry(entry(str, a)) {};
    type _entry;
};
struct STATUS_WORD
{
    static constexpr auto str = "STATUS_WORD=0x%04X";
    static constexpr auto str_short = "STATUS_WORD";
    using type = std::tuple<std::decay_t<decltype(str)>,uint16_t>;
    explicit constexpr STATUS_WORD(uint16_t a) : _entry(entry(str, a)) {};
    type _entry;
};
struct MFR_STATUS
{
    static constexpr auto str = "MFR_STATUS=0x%08X";
    static constexpr auto str_short = "MFR_STATUS";
    using type = std::tuple<std::decay_t<decltype(str)>,uint32_t>;
    explicit constexpr MFR_STATUS(uint32_t a) : _entry(entry(str, a)) {};
    type _entry;
};

}  // namespace _PowerSequencerPGOODFault

struct PowerSequencerPGOODFault
{
    static constexpr auto L = level::ERR;
    using INPUT_NUM = _PowerSequencerPGOODFault::INPUT_NUM;
    using INPUT_NAME = _PowerSequencerPGOODFault::INPUT_NAME;
    using INPUT_STATUS = _PowerSequencerPGOODFault::INPUT_STATUS;
    using STATUS_WORD = _PowerSequencerPGOODFault::STATUS_WORD;
    using MFR_STATUS = _PowerSequencerPGOODFault::MFR_STATUS;
    using metadata_types = std::tuple<INPUT_NUM, INPUT_NAME, INPUT_STATUS, STATUS_WORD, MFR_STATUS>;

};

} // namespace Fault
} // namespace Power
} // namespace openbmc_project
} // namespace xyz


namespace details
{

template <>
struct map_exception_type<sdbusplus::xyz::openbmc_project::Power::Fault::Error::PowerSequencerPGOODFault>
{
    using type = xyz::openbmc_project::Power::Fault::PowerSequencerPGOODFault;
};

}

namespace xyz
{
namespace openbmc_project
{
namespace Power
{
namespace Fault
{
namespace _PowerSequencerFault
{

struct STATUS_WORD
{
    static constexpr auto str = "STATUS_WORD=0x%04X";
    static constexpr auto str_short = "STATUS_WORD";
    using type = std::tuple<std::decay_t<decltype(str)>,uint16_t>;
    explicit constexpr STATUS_WORD(uint16_t a) : _entry(entry(str, a)) {};
    type _entry;
};
struct MFR_STATUS
{
    static constexpr auto str = "MFR_STATUS=0x%08X";
    static constexpr auto str_short = "MFR_STATUS";
    using type = std::tuple<std::decay_t<decltype(str)>,uint32_t>;
    explicit constexpr MFR_STATUS(uint32_t a) : _entry(entry(str, a)) {};
    type _entry;
};

}  // namespace _PowerSequencerFault

struct PowerSequencerFault
{
    static constexpr auto L = level::ERR;
    using STATUS_WORD = _PowerSequencerFault::STATUS_WORD;
    using MFR_STATUS = _PowerSequencerFault::MFR_STATUS;
    using metadata_types = std::tuple<STATUS_WORD, MFR_STATUS>;

};

} // namespace Fault
} // namespace Power
} // namespace openbmc_project
} // namespace xyz


namespace details
{

template <>
struct map_exception_type<sdbusplus::xyz::openbmc_project::Power::Fault::Error::PowerSequencerFault>
{
    using type = xyz::openbmc_project::Power::Fault::PowerSequencerFault;
};

}


} // namespace logging

} // namespace phosphor
